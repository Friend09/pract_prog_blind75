<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bipartite Graph Validation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #61afef;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        h2 {
            color: #e5c07b;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.8em;
            border-bottom: 2px solid #e5c07b;
            padding-bottom: 10px;
        }

        h3 {
            color: #98c379;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .intro {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #61afef;
        }

        .definition {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #e06c75;
        }

        .code-block {
            background: #282c34;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            border: 1px solid #3e4451;
            white-space: pre-wrap;
            line-height: 1.8;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 14px;
        }

        .keyword {
            color: #c678dd;
            font-weight: bold;
        }

        .function {
            color: #61afef;
        }

        .string {
            color: #98c379;
        }

        .number {
            color: #d19a66;
        }

        .comment {
            color: #5c6370;
            font-style: italic;
        }

        .variable {
            color: #e06c75;
        }

        .operator {
            color: #56b6c2;
        }

        .section {
            background: #2d2d2d;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .collapsible {
            background: #3e4451;
            color: #61afef;
            cursor: pointer;
            padding: 15px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.2em;
            border-radius: 8px;
            margin-top: 10px;
            transition: background 0.3s;
            font-weight: bold;
        }

        .collapsible:hover {
            background: #4e5561;
        }

        .collapsible.active {
            background: #4e5561;
        }

        .collapsible::after {
            content: ' ‚ñº';
            float: right;
        }

        .collapsible.active::after {
            content: ' ‚ñ≤';
        }

        .content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: #2d2d2d;
            border-radius: 0 0 8px 8px;
        }

        .content-inner {
            padding: 20px;
        }

        .step-box {
            background: #282c34;
            border-left: 4px solid #98c379;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .step-title {
            color: #e5c07b;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .graph-viz {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            background: #1e1e1e;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px solid #3e4451;
        }

        .node {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            border: 3px solid;
            position: relative;
        }

        .node.blue {
            background: #61afef;
            border-color: #528bcc;
            color: #1e1e1e;
        }

        .node.orange {
            background: #e5c07b;
            border-color: #c9a05c;
            color: #1e1e1e;
        }

        .node.uncolored {
            background: #3e4451;
            border-color: #5c6370;
            color: #d4d4d4;
        }

        .node.current {
            box-shadow: 0 0 20px rgba(97, 175, 239, 0.8);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(97, 175, 239, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(97, 175, 239, 1);
            }
        }

        .state-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #282c34;
            border-radius: 8px;
            overflow: hidden;
        }

        .state-table th {
            background: #3e4451;
            color: #e5c07b;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        .state-table td {
            padding: 12px;
            border-top: 1px solid #3e4451;
        }

        .state-table tr:hover {
            background: #2d2d2d;
        }

        .highlight {
            background: rgba(97, 175, 239, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .complexity-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .complexity-item {
            background: #282c34;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #c678dd;
        }

        .complexity-item h4 {
            color: #c678dd;
            margin-bottom: 10px;
        }

        .insight-box {
            background: linear-gradient(135deg, #2d2d2d 0%, #282c34 100%);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #61afef;
        }

        .insight-icon {
            color: #e5c07b;
            font-size: 1.2em;
            margin-right: 10px;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid;
        }

        .test-case {
            background: #282c34;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px solid #98c379;
        }

        .test-result {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }

        .test-result.pass {
            background: rgba(152, 195, 121, 0.2);
            color: #98c379;
        }

        .test-result.fail {
            background: rgba(224, 108, 117, 0.2);
            color: #e06c75;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Bipartite Graph Validation Algorithm</h1>
        
        <div class="intro">
            <p><strong>What is a Bipartite Graph?</strong></p>
            <p>A graph is <strong>bipartite</strong> if you can color all its nodes using only two colors such that no two adjacent (connected) nodes share the same color. Think of it like a team assignment where connected people must be on different teams.</p>
        </div>

        <div class="definition">
            <h3>üéØ The Challenge</h3>
            <p>Given an undirected graph represented as an adjacency list, determine if it's bipartite. The algorithm uses <strong>Depth-First Search (DFS)</strong> with color assignment to validate the graph.</p>
        </div>

        <h2>üìù The Algorithm Code</h2>
        <div class="code-block"><span class="keyword">from</span> typing <span class="keyword">import</span> List


<span class="keyword">def</span> <span class="function">bipartite_graph_validation</span>(graph: List[List[<span class="keyword">int</span>]]) -> <span class="keyword">bool</span>:
    <span class="comment"># Initialize colors array: 0 = uncolored, 1 = color A, -1 = color B</span>
    colors = [<span class="number">0</span>] * <span class="function">len</span>(graph)
    
    <span class="comment"># Check each component of the graph (handles disconnected graphs)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(graph)):
        <span class="comment"># If node is uncolored, start DFS with color 1</span>
        <span class="keyword">if</span> colors[i] == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="function">dfs</span>(i, <span class="number">1</span>, graph, colors):
            <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span>


<span class="keyword">def</span> <span class="function">dfs</span>(node: <span class="keyword">int</span>, color: <span class="keyword">int</span>, graph: List[List[<span class="keyword">int</span>]], colors: List[<span class="keyword">int</span>]) -> <span class="keyword">bool</span>:
    <span class="comment"># Assign the color to the current node</span>
    colors[node] = color
    
    <span class="comment"># Visit all neighbors</span>
    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:
        <span class="comment"># If neighbor has same color ‚Üí NOT bipartite!</span>
        <span class="keyword">if</span> colors[neighbor] == color:
            <span class="keyword">return</span> <span class="keyword">False</span>
        
        <span class="comment"># If neighbor is uncolored, color it with opposite color</span>
        <span class="keyword">if</span> colors[neighbor] == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="function">dfs</span>(neighbor, -color, graph, colors):
            <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span></div>

        <h2>üîç Key Concepts</h2>
        
        <div class="insight-box">
            <p><span class="insight-icon">üí°</span><strong>Color Representation:</strong></p>
            <ul>
                <li><span class="highlight">0</span> = Uncolored (not visited yet)</li>
                <li><span class="highlight">1</span> = Color A (Blue team)</li>
                <li><span class="highlight">-1</span> = Color B (Orange team)</li>
            </ul>
        </div>

        <div class="insight-box">
            <p><span class="insight-icon">üéØ</span><strong>Core Strategy:</strong></p>
            <p>Use DFS to traverse the graph while alternating colors. If we ever try to visit a node that's already colored with the same color as its parent, the graph is NOT bipartite.</p>
        </div>

        <button class="collapsible">Example 1: Valid Bipartite Graph ‚úÖ</button>
        <div class="content">
            <div class="content-inner">
                <h3>Graph Structure</h3>
                <p><strong>Input:</strong> graph = [[1, 4], [0, 2], [1], [4], [0, 3]]</p>
                
                <div class="graph-viz">
                    <svg width="500" height="400" viewBox="0 0 500 400">
                        <!-- Edges -->
                        <line x1="150" y1="100" x2="250" y2="100" stroke="#5c6370" stroke-width="3"/>
                        <line x1="150" y1="100" x2="100" y2="250" stroke="#5c6370" stroke-width="3"/>
                        <line x1="250" y1="100" x2="350" y2="250" stroke="#5c6370" stroke-width="3"/>
                        <line x1="100" y1="250" x2="200" y2="300" stroke="#5c6370" stroke-width="3"/>
                        
                        <!-- Nodes -->
                        <circle cx="150" cy="100" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="150" y="110" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">0</text>
                        
                        <circle cx="250" cy="100" r="35" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                        <text x="250" y="110" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">1</text>
                        
                        <circle cx="350" cy="250" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="350" y="260" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">2</text>
                        
                        <circle cx="100" cy="250" r="35" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                        <text x="100" y="260" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">4</text>
                        
                        <circle cx="200" cy="300" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="200" y="310" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">3</text>
                    </svg>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #61afef; border-color: #528bcc;"></div>
                        <span>Color 1 (Blue Team)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e5c07b; border-color: #c9a05c;"></div>
                        <span>Color -1 (Orange Team)</span>
                    </div>
                </div>

                <h3>Step-by-Step Execution</h3>

                <div class="step-box">
                    <div class="step-title">Step 1: Initialize</div>
                    <p><strong>colors array:</strong> [0, 0, 0, 0, 0]</p>
                    <p>Start at node 0 since colors[0] == 0</p>
                    <p><strong>Call:</strong> dfs(node=0, color=1)</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 2: Color Node 0</div>
                    <p><strong>Action:</strong> colors[0] = 1</p>
                    <p><strong>colors array:</strong> [<span class="highlight">1</span>, 0, 0, 0, 0]</p>
                    <p><strong>Neighbors of 0:</strong> [1, 4]</p>
                    <p>Process neighbor 1 first...</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 3: Process Node 1</div>
                    <p><strong>Call:</strong> dfs(node=1, color=-1)</p>
                    <p><strong>Action:</strong> colors[1] = -1</p>
                    <p><strong>colors array:</strong> [1, <span class="highlight">-1</span>, 0, 0, 0]</p>
                    <p><strong>Neighbors of 1:</strong> [0, 2]</p>
                    <p>Node 0 already colored (1), and -1 ‚â† 1 ‚úÖ</p>
                    <p>Process neighbor 2...</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 4: Process Node 2</div>
                    <p><strong>Call:</strong> dfs(node=2, color=1)</p>
                    <p><strong>Action:</strong> colors[2] = 1</p>
                    <p><strong>colors array:</strong> [1, -1, <span class="highlight">1</span>, 0, 0]</p>
                    <p><strong>Neighbors of 2:</strong> [1]</p>
                    <p>Node 1 already colored (-1), and 1 ‚â† -1 ‚úÖ</p>
                    <p>Return True, backtrack to node 1</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 5: Backtrack to Node 0</div>
                    <p>Return to node 0, process next neighbor: 4</p>
                    <p><strong>Call:</strong> dfs(node=4, color=-1)</p>
                    <p><strong>Action:</strong> colors[4] = -1</p>
                    <p><strong>colors array:</strong> [1, -1, 1, 0, <span class="highlight">-1</span>]</p>
                    <p><strong>Neighbors of 4:</strong> [0, 3]</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 6: Process Node 3</div>
                    <p><strong>Call:</strong> dfs(node=3, color=1)</p>
                    <p><strong>Action:</strong> colors[3] = 1</p>
                    <p><strong>colors array:</strong> [1, -1, 1, <span class="highlight">1</span>, -1]</p>
                    <p><strong>Neighbors of 3:</strong> [4]</p>
                    <p>Node 4 already colored (-1), and 1 ‚â† -1 ‚úÖ</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 7: Complete</div>
                    <p><strong>Final colors:</strong> [1, -1, 1, 1, -1]</p>
                    <p><strong>Result:</strong> <span class="test-result pass">TRUE - Graph is bipartite!</span></p>
                    <p>All adjacent nodes have different colors ‚úÖ</p>
                </div>

                <h3>State Table</h3>
                <table class="state-table">
                    <thead>
                        <tr>
                            <th>Step</th>
                            <th>Current Node</th>
                            <th>Assigned Color</th>
                            <th>Colors Array</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                            <td>[1, 0, 0, 0, 0]</td>
                            <td>Start DFS from node 0</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>1</td>
                            <td>-1</td>
                            <td>[1, -1, 0, 0, 0]</td>
                            <td>Color opposite of node 0</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>2</td>
                            <td>1</td>
                            <td>[1, -1, 1, 0, 0]</td>
                            <td>Color opposite of node 1</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>4</td>
                            <td>-1</td>
                            <td>[1, -1, 1, 0, -1]</td>
                            <td>Color opposite of node 0</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>3</td>
                            <td>1</td>
                            <td>[1, -1, 1, 1, -1]</td>
                            <td>Color opposite of node 4</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <button class="collapsible">Example 2: Invalid Bipartite Graph (Odd Cycle) ‚ùå</button>
        <div class="content">
            <div class="content-inner">
                <h3>Graph Structure</h3>
                <p><strong>Input:</strong> graph = [[1, 2], [0, 2], [0, 1]]</p>
                <p>This forms a triangle - an odd cycle!</p>
                
                <div class="graph-viz">
                    <svg width="400" height="400" viewBox="0 0 400 400">
                        <!-- Edges -->
                        <line x1="200" y1="100" x2="120" y2="250" stroke="#5c6370" stroke-width="3"/>
                        <line x1="200" y1="100" x2="280" y2="250" stroke="#5c6370" stroke-width="3"/>
                        <line x1="120" y1="250" x2="280" y2="250" stroke="#e06c75" stroke-width="4" stroke-dasharray="5,5"/>
                        
                        <!-- Nodes -->
                        <circle cx="200" cy="100" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="200" y="110" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">0</text>
                        
                        <circle cx="120" cy="250" r="35" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                        <text x="120" y="260" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">1</text>
                        
                        <circle cx="280" cy="250" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="280" y="260" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">2</text>
                        
                        <!-- Error indicator -->
                        <text x="200" y="280" text-anchor="middle" fill="#e06c75" font-size="18" font-weight="bold">‚ö†Ô∏è CONFLICT!</text>
                    </svg>
                </div>

                <h3>Step-by-Step Execution</h3>

                <div class="step-box">
                    <div class="step-title">Step 1: Initialize & Start</div>
                    <p><strong>colors array:</strong> [0, 0, 0]</p>
                    <p><strong>Call:</strong> dfs(node=0, color=1)</p>
                    <p><strong>Action:</strong> colors[0] = 1</p>
                    <p><strong>colors array:</strong> [<span class="highlight">1</span>, 0, 0]</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 2: Color Node 1</div>
                    <p><strong>Neighbors of 0:</strong> [1, 2]</p>
                    <p><strong>Call:</strong> dfs(node=1, color=-1)</p>
                    <p><strong>Action:</strong> colors[1] = -1</p>
                    <p><strong>colors array:</strong> [1, <span class="highlight">-1</span>, 0]</p>
                    <p><strong>Neighbors of 1:</strong> [0, 2]</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 3: Color Node 2</div>
                    <p>From node 1, visit neighbor 2</p>
                    <p><strong>Call:</strong> dfs(node=2, color=1)</p>
                    <p><strong>Action:</strong> colors[2] = 1</p>
                    <p><strong>colors array:</strong> [1, -1, <span class="highlight">1</span>]</p>
                    <p><strong>Neighbors of 2:</strong> [0, 1]</p>
                    <p>Check neighbor 0: colors[0] = 1 ‚úÖ (different from -1)</p>
                    <p>Check neighbor 1: colors[1] = -1 ‚úÖ (different from 1)</p>
                    <p>Return True, backtrack to node 1</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 4: Backtrack to Node 0 - CONFLICT! ‚ö†Ô∏è</div>
                    <p>Now process second neighbor of node 0: node 2</p>
                    <p>Node 2 is already colored with 1</p>
                    <p><strong>Check:</strong> colors[2] == color? ‚Üí 1 == 1? ‚Üí <strong>YES!</strong></p>
                    <p><strong>Result:</strong> Node 0 (color 1) is adjacent to node 2 (color 1)</p>
                    <p style="color: #e06c75; font-weight: bold;">‚ùå SAME COLOR DETECTED - NOT BIPARTITE!</p>
                    <p>Return False immediately</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Why This Fails</div>
                    <p>Triangle (3-node cycle) is an <strong>odd cycle</strong></p>
                    <p>In any odd cycle, you cannot alternate colors without creating a conflict</p>
                    <p>Nodes 0 ‚Üí 1 ‚Üí 2 ‚Üí 0 requires 3 colors, but we only have 2!</p>
                </div>

                <h3>State Table</h3>
                <table class="state-table">
                    <thead>
                        <tr>
                            <th>Step</th>
                            <th>Current Node</th>
                            <th>Assigned Color</th>
                            <th>Colors Array</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>0</td>
                            <td>1</td>
                            <td>[1, 0, 0]</td>
                            <td>‚úÖ OK</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>1</td>
                            <td>-1</td>
                            <td>[1, -1, 0]</td>
                            <td>‚úÖ OK</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>2</td>
                            <td>1</td>
                            <td>[1, -1, 1]</td>
                            <td>‚úÖ OK (initially)</td>
                        </tr>
                        <tr style="background: rgba(224, 108, 117, 0.2);">
                            <td>4</td>
                            <td>0 ‚Üí 2</td>
                            <td>Conflict</td>
                            <td>[1, -1, 1]</td>
                            <td>‚ùå CONFLICT: nodes 0 and 2 both color 1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <button class="collapsible">Example 3: Disconnected Graph with Multiple Components ‚úÖ</button>
        <div class="content">
            <div class="content-inner">
                <h3>Graph Structure</h3>
                <p><strong>Input:</strong> graph = [[1], [0], [3], [2]]</p>
                <p>This graph has TWO disconnected components!</p>
                
                <div class="graph-viz">
                    <svg width="500" height="300" viewBox="0 0 500 300">
                        <!-- Component 1 -->
                        <line x1="100" y1="150" x2="200" y2="150" stroke="#5c6370" stroke-width="3"/>
                        <circle cx="100" cy="150" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="100" y="160" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">0</text>
                        <circle cx="200" cy="150" r="35" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                        <text x="200" y="160" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">1</text>
                        
                        <!-- Component 2 -->
                        <line x1="300" y1="150" x2="400" y2="150" stroke="#5c6370" stroke-width="3"/>
                        <circle cx="300" cy="150" r="35" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                        <text x="300" y="160" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">2</text>
                        <circle cx="400" cy="150" r="35" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                        <text x="400" y="160" text-anchor="middle" fill="#1e1e1e" font-size="24" font-weight="bold">3</text>
                        
                        <!-- Labels -->
                        <text x="150" y="80" text-anchor="middle" fill="#98c379" font-size="16">Component 1</text>
                        <text x="350" y="80" text-anchor="middle" fill="#98c379" font-size="16">Component 2</text>
                    </svg>
                </div>

                <h3>Step-by-Step Execution</h3>

                <div class="step-box">
                    <div class="step-title">Phase 1: Process Component 1</div>
                    <p><strong>colors array:</strong> [0, 0, 0, 0]</p>
                    <p>Loop iteration i=0: colors[0] == 0, start DFS</p>
                    <p><strong>Call:</strong> dfs(node=0, color=1)</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 1: Color Nodes 0 and 1</div>
                    <p><strong>Action:</strong> colors[0] = 1</p>
                    <p><strong>Neighbors of 0:</strong> [1]</p>
                    <p><strong>Call:</strong> dfs(node=1, color=-1)</p>
                    <p><strong>Action:</strong> colors[1] = -1</p>
                    <p><strong>colors array:</strong> [<span class="highlight">1</span>, <span class="highlight">-1</span>, 0, 0]</p>
                    <p>Component 1 complete! Return True</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Phase 2: Process Component 2</div>
                    <p>Loop iteration i=1: colors[1] == -1, skip (already colored)</p>
                    <p>Loop iteration i=2: colors[2] == 0, start new DFS</p>
                    <p><strong>Call:</strong> dfs(node=2, color=1)</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 2: Color Nodes 2 and 3</div>
                    <p><strong>Action:</strong> colors[2] = 1</p>
                    <p><strong>Neighbors of 2:</strong> [3]</p>
                    <p><strong>Call:</strong> dfs(node=3, color=-1)</p>
                    <p><strong>Action:</strong> colors[3] = -1</p>
                    <p><strong>Final colors array:</strong> [1, -1, <span class="highlight">1</span>, <span class="highlight">-1</span>]</p>
                    <p>Component 2 complete! Return True</p>
                </div>

                <div class="step-box">
                    <div class="step-title">Step 3: Complete</div>
                    <p>All components processed successfully!</p>
                    <p><strong>Result:</strong> <span class="test-result pass">TRUE - Graph is bipartite!</span></p>
                    <p>Each component is independently bipartite ‚úÖ</p>
                </div>

                <div class="insight-box">
                    <p><span class="insight-icon">üí°</span><strong>Key Insight:</strong></p>
                    <p>The outer loop handles disconnected graphs by starting a new DFS from any unvisited node. This ensures we check ALL components of the graph.</p>
                </div>
            </div>
        </div>

        <button class="collapsible">Example 4: Single Node & Edge Cases</button>
        <div class="content">
            <div class="content-inner">
                <h3>Test Case 1: Single Node</h3>
                <div class="test-case">
                    <p><strong>Input:</strong> graph = [[]]</p>
                    <p><strong>Result:</strong> <span class="test-result pass">TRUE</span></p>
                    <p><strong>Explanation:</strong> A single node with no edges is trivially bipartite</p>
                    <p><strong>Execution:</strong></p>
                    <ul>
                        <li>colors = [0]</li>
                        <li>Start DFS at node 0 with color 1</li>
                        <li>colors[0] = 1</li>
                        <li>No neighbors to process</li>
                        <li>Return True</li>
                    </ul>
                </div>

                <h3>Test Case 2: Two Nodes Connected</h3>
                <div class="test-case">
                    <p><strong>Input:</strong> graph = [[1], [0]]</p>
                    <p><strong>Result:</strong> <span class="test-result pass">TRUE</span></p>
                    <p><strong>Explanation:</strong> Two nodes can always be colored differently</p>
                    <p><strong>Execution:</strong></p>
                    <ul>
                        <li>colors = [0, 0]</li>
                        <li>DFS from 0 with color 1 ‚Üí colors = [1, 0]</li>
                        <li>Visit neighbor 1, color with -1 ‚Üí colors = [1, -1]</li>
                        <li>Check neighbor of 1 (node 0), already colored with 1 ‚â† -1 ‚úÖ</li>
                    </ul>
                </div>

                <h3>Test Case 3: Square (4-node Even Cycle)</h3>
                <div class="test-case">
                    <p><strong>Input:</strong> graph = [[1, 3], [0, 2], [1, 3], [0, 2]]</p>
                    <p><strong>Result:</strong> <span class="test-result pass">TRUE</span></p>
                    <p><strong>Explanation:</strong> Even cycles are always bipartite</p>
                    <div class="graph-viz">
                        <svg width="300" height="300" viewBox="0 0 300 300">
                            <line x1="100" y1="100" x2="200" y2="100" stroke="#5c6370" stroke-width="3"/>
                            <line x1="200" y1="100" x2="200" y2="200" stroke="#5c6370" stroke-width="3"/>
                            <line x1="200" y1="200" x2="100" y2="200" stroke="#5c6370" stroke-width="3"/>
                            <line x1="100" y1="200" x2="100" y2="100" stroke="#5c6370" stroke-width="3"/>
                            
                            <circle cx="100" cy="100" r="30" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                            <text x="100" y="110" text-anchor="middle" fill="#1e1e1e" font-size="20" font-weight="bold">0</text>
                            
                            <circle cx="200" cy="100" r="30" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                            <text x="200" y="110" text-anchor="middle" fill="#1e1e1e" font-size="20" font-weight="bold">1</text>
                            
                            <circle cx="200" cy="200" r="30" fill="#61afef" stroke="#528bcc" stroke-width="3"/>
                            <text x="200" y="210" text-anchor="middle" fill="#1e1e1e" font-size="20" font-weight="bold">2</text>
                            
                            <circle cx="100" cy="200" r="30" fill="#e5c07b" stroke="#c9a05c" stroke-width="3"/>
                            <text x="100" y="210" text-anchor="middle" fill="#1e1e1e" font-size="20" font-weight="bold">3</text>
                        </svg>
                    </div>
                    <p>Colors alternate around the cycle: [1, -1, 1, -1]</p>
                </div>

                <h3>Test Case 4: Pentagon (5-node Odd Cycle)</h3>
                <div class="test-case">
                    <p><strong>Input:</strong> graph = [[1, 4], [0, 2], [1, 3], [2, 4], [0, 3]]</p>
                    <p><strong>Result:</strong> <span class="test-result fail">FALSE</span></p>
                    <p><strong>Explanation:</strong> All odd cycles are NOT bipartite</p>
                    <p>When you try to color a cycle with an odd number of nodes, you'll eventually encounter a conflict where two adjacent nodes have the same color.</p>
                </div>
            </div>
        </div>

        <h2>üß† Algorithm Insights</h2>

        <div class="section">
            <h3>Why This Algorithm Works</h3>
            
            <div class="insight-box">
                <p><span class="insight-icon">üéØ</span><strong>Core Principle:</strong></p>
                <p>A graph is bipartite if and only if it contains <strong>no odd-length cycles</strong>. The algorithm detects odd cycles by attempting to 2-color the graph using DFS.</p>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">üîÑ</span><strong>The DFS Strategy:</strong></p>
                <ul>
                    <li><strong>Alternating Colors:</strong> Each time we traverse an edge, we flip the color (1 ‚Üí -1 or -1 ‚Üí 1)</li>
                    <li><strong>Conflict Detection:</strong> If we reach a node that's already colored with the same color as its parent, we've found an odd cycle</li>
                    <li><strong>Backtracking:</strong> DFS naturally explores all paths, ensuring we check every edge</li>
                </ul>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">üå≤</span><strong>Why DFS Over BFS?</strong></p>
                <p>Both DFS and BFS work for this problem! DFS is chosen here because:</p>
                <ul>
                    <li>Simpler recursive implementation</li>
                    <li>Less memory overhead (no queue needed)</li>
                    <li>Natural backtracking behavior</li>
                </ul>
                <p>BFS would be equally valid and might be preferred for finding shortest odd cycles.</p>
            </div>
        </div>

        <h2>‚ö° Complexity Analysis</h2>

        <div class="complexity-box">
            <div class="complexity-item">
                <h4>‚è±Ô∏è Time Complexity: O(V + E)</h4>
                <p><strong>V</strong> = number of vertices (nodes)</p>
                <p><strong>E</strong> = number of edges</p>
                <p><strong>Why?</strong></p>
                <ul>
                    <li>We visit each vertex exactly once</li>
                    <li>We examine each edge exactly twice (once from each endpoint)</li>
                    <li>The outer loop iterates V times</li>
                    <li>DFS processes each neighbor once</li>
                </ul>
            </div>

            <div class="complexity-item">
                <h4>üíæ Space Complexity: O(V)</h4>
                <p><strong>Components:</strong></p>
                <ul>
                    <li><strong>colors array:</strong> O(V) - stores color for each node</li>
                    <li><strong>Call stack:</strong> O(V) worst case - if graph is a long chain</li>
                    <li>No additional data structures needed</li>
                </ul>
                <p><strong>Total:</strong> O(V) + O(V) = O(V)</p>
            </div>
        </div>

        <h2>üéì Key Takeaways</h2>

        <div class="section">
            <div class="insight-box">
                <p><span class="insight-icon">‚úÖ</span><strong>When to Use Bipartite Checking:</strong></p>
                <ul>
                    <li><strong>Matching Problems:</strong> Assigning jobs to workers, students to projects</li>
                    <li><strong>Conflict Detection:</strong> Scheduling events, resource allocation</li>
                    <li><strong>Two-Group Classification:</strong> Team assignments, side selection</li>
                    <li><strong>Graph Coloring:</strong> Map coloring with 2 colors, chess board problems</li>
                </ul>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">üîç</span><strong>Pattern Recognition:</strong></p>
                <ul>
                    <li><strong>Even cycles:</strong> Always bipartite ‚úÖ</li>
                    <li><strong>Odd cycles:</strong> Never bipartite ‚ùå</li>
                    <li><strong>Trees:</strong> Always bipartite ‚úÖ (no cycles)</li>
                    <li><strong>Complete graphs K<sub>n</sub>:</strong> Only K<sub>2</sub> is bipartite</li>
                </ul>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">‚öôÔ∏è</span><strong>Algorithm Variations:</strong></p>
                <ul>
                    <li><strong>BFS Approach:</strong> Use queue instead of recursion, same logic</li>
                    <li><strong>Union-Find:</strong> Can detect bipartiteness using disjoint sets</li>
                    <li><strong>Iterative DFS:</strong> Explicit stack to avoid recursion depth limits</li>
                </ul>
            </div>
        </div>

        <h2>üß™ Interactive Test Cases</h2>

        <div class="section">
            <h3>Test the Algorithm</h3>
            
            <div class="test-case">
                <h4>Test 1: Linear Chain</h4>
                <p><strong>graph = [[1], [0, 2], [1, 3], [2]]</strong></p>
                <p><strong>Expected:</strong> <span class="test-result pass">TRUE</span></p>
                <p><strong>Reasoning:</strong> Linear chain has no cycles, always bipartite</p>
                <p><strong>Colors:</strong> [1, -1, 1, -1] - Perfect alternation!</p>
            </div>

            <div class="test-case">
                <h4>Test 2: Complete Bipartite K<sub>3,3</sub></h4>
                <p><strong>graph = [[3, 4, 5], [3, 4, 5], [3, 4, 5], [0, 1, 2], [0, 1, 2], [0, 1, 2]]</strong></p>
                <p><strong>Expected:</strong> <span class="test-result pass">TRUE</span></p>
                <p><strong>Reasoning:</strong> Complete bipartite graphs are by definition bipartite</p>
                <p><strong>Colors:</strong> [1, 1, 1, -1, -1, -1] - Two clear groups!</p>
            </div>

            <div class="test-case">
                <h4>Test 3: Star Graph (Center + Leaves)</h4>
                <p><strong>graph = [[1, 2, 3, 4], [0], [0], [0], [0]]</strong></p>
                <p><strong>Expected:</strong> <span class="test-result pass">TRUE</span></p>
                <p><strong>Reasoning:</strong> Center gets one color, all leaves get the other</p>
                <p><strong>Colors:</strong> [1, -1, -1, -1, -1]</p>
            </div>

            <div class="test-case">
                <h4>Test 4: Hexagon (6-node Even Cycle)</h4>
                <p><strong>graph = [[1, 5], [0, 2], [1, 3], [2, 4], [3, 5], [4, 0]]</strong></p>
                <p><strong>Expected:</strong> <span class="test-result pass">TRUE</span></p>
                <p><strong>Reasoning:</strong> Even cycle - colors alternate perfectly around the loop</p>
            </div>

            <div class="test-case">
                <h4>Test 5: Complete Graph K<sub>4</sub></h4>
                <p><strong>graph = [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]</strong></p>
                <p><strong>Expected:</strong> <span class="test-result fail">FALSE</span></p>
                <p><strong>Reasoning:</strong> Contains multiple triangles (odd cycles)</p>
            </div>
        </div>

        <h2>üíª Python Implementation with Testing</h2>

        <div class="code-block"><span class="keyword">from</span> typing <span class="keyword">import</span> List


<span class="keyword">def</span> <span class="function">bipartite_graph_validation</span>(graph: List[List[<span class="keyword">int</span>]]) -> <span class="keyword">bool</span>:
    <span class="string">"""
    Determines if an undirected graph is bipartite.
    
    Args:
        graph: Adjacency list representation where graph[i] contains
               all nodes adjacent to node i
    
    Returns:
        True if the graph is bipartite, False otherwise
    
    Time: O(V + E) where V = vertices, E = edges
    Space: O(V) for colors array and recursion stack
    """</span>
    n = <span class="function">len</span>(graph)
    colors = [<span class="number">0</span>] * n  <span class="comment"># 0 = unvisited, 1 = color A, -1 = color B</span>
    
    <span class="comment"># Check each connected component</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(n):
        <span class="keyword">if</span> colors[i] == <span class="number">0</span>:  <span class="comment"># Unvisited node</span>
            <span class="keyword">if</span> <span class="keyword">not</span> <span class="function">dfs</span>(i, <span class="number">1</span>, graph, colors):
                <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span>


<span class="keyword">def</span> <span class="function">dfs</span>(node: <span class="keyword">int</span>, color: <span class="keyword">int</span>, graph: List[List[<span class="keyword">int</span>]], colors: List[<span class="keyword">int</span>]) -> <span class="keyword">bool</span>:
    <span class="string">"""
    DFS helper to color the graph and detect conflicts.
    
    Args:
        node: Current node to color
        color: Color to assign (1 or -1)
        graph: Adjacency list
        colors: Array tracking node colors
    
    Returns:
        True if coloring is valid, False if conflict detected
    """</span>
    colors[node] = color
    
    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:
        <span class="comment"># Conflict: neighbor has same color</span>
        <span class="keyword">if</span> colors[neighbor] == color:
            <span class="keyword">return</span> <span class="keyword">False</span>
        
        <span class="comment"># Recursively color unvisited neighbors with opposite color</span>
        <span class="keyword">if</span> colors[neighbor] == <span class="number">0</span>:
            <span class="keyword">if</span> <span class="keyword">not</span> <span class="function">dfs</span>(neighbor, -color, graph, colors):
                <span class="keyword">return</span> <span class="keyword">False</span>
    
    <span class="keyword">return</span> <span class="keyword">True</span>


<span class="comment"># Test the algorithm</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Test 1: Valid bipartite (from problem example)</span>
    graph1 = [[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>], [<span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>]]
    <span class="function">print</span>(<span class="string">f"Test 1: {bipartite_graph_validation(graph1)}"</span>)  <span class="comment"># True</span>
    
    <span class="comment"># Test 2: Triangle (odd cycle)</span>
    graph2 = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>]]
    <span class="function">print</span>(<span class="string">f"Test 2: {bipartite_graph_validation(graph2)}"</span>)  <span class="comment"># False</span>
    
    <span class="comment"># Test 3: Disconnected components</span>
    graph3 = [[<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">3</span>], [<span class="number">2</span>]]
    <span class="function">print</span>(<span class="string">f"Test 3: {bipartite_graph_validation(graph3)}"</span>)  <span class="comment"># True</span>
    
    <span class="comment"># Test 4: Square (even cycle)</span>
    graph4 = [[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>]]
    <span class="function">print</span>(<span class="string">f"Test 4: {bipartite_graph_validation(graph4)}"</span>)  <span class="comment"># True</span></div>

        <h2>üéØ Summary</h2>

        <div class="section">
            <div class="insight-box">
                <p><span class="insight-icon">üìå</span><strong>The Algorithm in One Sentence:</strong></p>
                <p>Use DFS to attempt 2-coloring the graph by alternating colors across edges; if any adjacent nodes end up with the same color, the graph is not bipartite.</p>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">üé®</span><strong>Real-World Analogy:</strong></p>
                <p>Imagine you're organizing a party where certain guests don't get along (connected by edges). You want to seat them at two tables (two colors) such that no conflicting guests sit at the same table. If you can do this successfully, your party graph is bipartite!</p>
            </div>

            <div class="insight-box">
                <p><span class="insight-icon">‚ö°</span><strong>Quick Facts:</strong></p>
                <ul>
                    <li>‚úÖ Efficient: O(V + E) time, O(V) space</li>
                    <li>‚úÖ Handles disconnected graphs automatically</li>
                    <li>‚úÖ Works for any size graph</li>
                    <li>‚ùå Odd cycles always fail</li>
                    <li>‚úÖ Trees always succeed</li>
                </ul>
            </div>
        </div>

    </div>

    <script>
        // Collapsible sections functionality
        const collapsibles = document.querySelectorAll('.collapsible');
        
        collapsibles.forEach(button => {
            button.addEventListener('click', function() {
                this.classList.toggle('active');
                const content = this.nextElementSibling;
                
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        });

        // Auto-expand first example
        if (collapsibles.length > 0) {
            collapsibles[0].click();
        }
    </script>
</body>
</html>